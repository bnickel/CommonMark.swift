#!/usr/bin/env perl
use warnings;
use strict;
use IO::Handle;

my $SPEC = shift @ARGV;

# Markdown implementations vary on insignificant whitespace.
# Some leave blanks between block elements, others don't.
# This function tries to normalize the output so it can be
# compared with our test.  tidy takes two arguments: the
# string containing the actual output, and a pathname of the
# file to which the tidied output is to be saved.
sub tidy
{
  my $inpre = 0;
  my $out = "";
  my $outfh;
  open($outfh, '>', \$out);
  for (split /^/, $_[0]) {
    if (/<pre/) {
      $inpre = 1;
    } elsif (/<\/pre/) {
      $inpre = 0;
    }
    if ($inpre) {
      print $outfh $_;
    } else {
      # remove leading spaces
      s/^  *//;
      # remove trailing spaces
      s/  *$//;
      # collapse consecutive spaces
      s/  */ /;
      # collapse space before /> in tag
      s/  *\/>/\/>/;
      # skip blank line
      if (/^$/) {
        next;
      }
      print $outfh $_;
    }
  }
  close $outfh;
  return $out;
}

sub writetest
{
  my $markdown = $_[0];
  my $html = $_[1];
  my $testname = $_[2];
  my $actual = "";
  # We use → to indicate tab and ␣ space in the spec
  $markdown =~ s/→/\t/g;s/␣/ /g;
  $html =~ s/→/\t/g;s/␣/ /g;
  # $html   = &tidy($html);

  $markdown =~ s/\\/\\\\/g;
  $markdown =~ s/\n/\\n/g;
  $markdown =~ s/"/\\"/g;
  $markdown =~ s/\t/\\t/g;
  $html =~ s/\\/\\\\/g;
  $html =~ s/\n/\\n/g;
  $html =~ s/\"/\\"/g;

  print "\n    func $testname() {";
  print "\n        XCTAssertEqual(HTMLRenderer().renderBlock(parse(\"${markdown}\")), \"${html}\", \"Source:\\n\\n${markdown}\\n\")";
  print "\n    }\n\n";
}

my $stage = 0;
my $markdown = "";
my $html = "";
my $example = 0;
my $linenum = 0;
my $exampleline = 0;
my @secnums = ();
my $secheading;
my $firstsection = 1;

print "//Autogenerated code.  Do not change.\n\nimport CommonMarkdown\nimport XCTest\n\n";

open(SPEC, "< $SPEC");
while (<SPEC>) {
  $linenum++;
  if (/^\.$/) {
      $stage = ($stage + 1) % 3;
      if ($stage == 1) {
          $exampleline = $linenum;
      }
      if ($stage == 0) {
          $example++;
          writetest($markdown, $html, "testExample${example}FromLine$exampleline");
          $markdown = "";
          $html = "";
      }
  } elsif ($stage == 0 && $_ =~ /^<!-- END TESTS -->/) {
      last;
  } elsif ($stage == 0 && $_ =~ /^(#+) +(.*)/) {
      my $seclevel = length($1);
      $secheading = $2;
      if ($#secnums == $seclevel - 1) {
          $secnums[$#secnums]++;
      } elsif ($#secnums > $seclevel - 1) {
          @secnums = @secnums[0..($seclevel - 1)];
          $secnums[$#secnums]++;
      } else {
          while ($#secnums < $seclevel - 1) {
              push(@secnums, 1);
          }
      }

      if ($firstsection == 0) {
        print "}\n\n";
      }
      $firstsection = 0;

      $secheading =~ s/\W/_/g;
      print ("\n", "class Section_" . join("_", @secnums) . "_" . $secheading, " : XCTestCase {\n");
  } elsif ($stage == 1) {
      $markdown .= $_;
  } elsif ($stage == 2) {
      $html .= $_;
  }
}

print "}";

exit 0
